trigger: none
name: "SFS Environment Update"

parameters:
  - name: performTests
    displayName: "Run tests?"
    type: boolean
    default: true
  - name: Ignore test failures
    displayName: "Ignore test failures?"
    type: boolean
    default: false
    # We can override these defaults in the pipeline
  - name: environment
    displayName: "DevOps Output [dev, at, test, demo, oat, release]"
    type: string
    default: dev
    values:
    - dev
    - at
    - test
    - demo
    - oat
    - release
  - name: resourceManagerConnectionName
    displayName: "DevOps [Azure Resource Manager service connection name, default is fine on lower environments]"
    type: string
    default: "PDS-DEV-RM"
  - name: subscriptionId
    displayName: "DevOps [Subscription Id, default is fine on lower environments]"
    type: string
    # this isn't a secret, so we can just put it in here
    default: "345c3752-8e54-4077-90db-93ff12333be0"
  - name: nugetFeed
    displayName: "DevOps [NuGet feed ID, default PDS]"
    type: string
    default: '9fd46a3f-eada-41dc-86e9-36332aeb8ef1/ecd5af68-0566-42db-8cd7-e71176254aa2'

variables:
  # This can be inferred from the environment
  - name: resourceGroupName
    value: "pds-${{ parameters.environment }}-shared-rg"
  - name: overrideParams
    value: "-environment ${{ parameters.environment }}"

jobs:
  - job: infra
    displayName: "Update/Deploy Infrastructure"
    pool:
      # This is pretty much one of the only steps here we can run on linux
      vmImage: "ubuntu-latest"
    steps:
      - task: AzureResourceManagerTemplateDeployment@3
        inputs:
          deploymentScope: "Resource Group"
          azureResourceManagerConnection: "${{ parameters.resourceManagerConnectionName }}"
          subscriptionId: "${{ parameters.subscriptionId }}"
          action: "Create Or Update Resource Group"
          resourceGroupName: "${{ variables.resourceGroupName }}"
          location: "West Europe"
          templateLocation: "Linked artifact"
          csmFile: "AppService.bicep"
          overrideParameters: "${{ variables.overrideParams }}"
          deploymentMode: "Incremental"
  - job: build
    pool:
      vmImage: "windows-latest"
    steps:
      # We are submoduled, so no need to checkout the main repo. Let's just do the powershell stuff
      # All the env vars are automatically created
      - task: PowerShell@1
        displayName: 'Set Version Numbers'
        inputs:
          scriptName: BuildScripts/SetVersionNumbers.ps1
      - task: NuGetCommand@2
        displayName: 'Set up dependencies'
        inputs:
          restoreSolution: ProviderDigitalServices.sln
          vstsFeed: '${{ parameters.nugetFeed }}'

      - task: VSBuild@1
        displayName: 'Build solution ProviderDigitalServices.sln'
        inputs:
          solution: ProviderDigitalServices.sln
          # VS 2022
          vsVersion: "17.0"
          # Same as passing /m
          maximumCpuCount: true 
          platform: x64
          msbuildArchitecture: x64
          # This reflects the environment we are building for
          configuration: '${{ parameters.environment }}'
          clean: true

      # This is from VSCode market: https://marketplace.visualstudio.com/items?itemName=qetza.replacetokens
      - task: qetza.replacetokens.replacetokens-task.replacetokens@6
        displayName: 'Replace tokens in **/*.config **/*.wadcfgx **/*.cscfg'
        inputs:
          sources: '**/*.config; **/*.wadcfgx; **/*.cscfg;'
          tokenPattern: doubleunderscores
          telemetryOptout: true
      
      # This is our actual build
      - task: VSBuild@1
        displayName: 'Publish: ProviderDigitalServices.Azure.Deploy'
        inputs:
          solution: ProviderDigitalServices.Azure.Deploy/ProviderDigitalServices.Azure.Deploy.ccproj
          vsVersion: "17.0"
          msbuildArgs: '/t:Publish /p:PublishDir="$(build.artifactstagingdirectory)\ProviderDigitalServices.Azure.Deploy"'
          platform: '$(BuildPlatform)'
          configuration: '$(BuildConfiguration)'
          clean: true
          maximumCpuCount: true
          msbuildArchitecture: x64
  # The test job runs only if the parameter is set to true
  # it depends on above and needs to run on the same agent as the build task
  # NB: I *think* this will work across agents - if not I will need to create an agent pool above
  - job: test
  # Only run if build succeeds and tests pass. This only depends on build, unlike the initial deploy
  # which needs the bicep to be deployed first
    dependsOn: build
    condition: and(succeeded(), eq('${{ parameters.performTests }}', 'true'))

  # Deploy to Azure job can run alongside tests, BUT we deploy to the inactive slot
  # and swap only if the tests pass
  - job: deploy

  
  # This job is only run if the tests pass and the deploy job is successful
  # We change slot settings and swap the slots

  # Make live depends on the test AND deploy jobs being successful (or skipped). If test was unsuccessful then we can
  # still deploy if parameters.ignoreTestFailures is set to true
  - job: makeLive
  

